#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <list>
#include <stack>
#include <set>
#include <queue>
#include <algorithm>
#include <ctime>
#include <deque>
#include <math.h>
#include <climits>
#include <cstring>
#include <fstream>

using namespace std;

const bool OUTPUT_GAME_DATA = 1;
const bool USE_HARDCODED_INPUT = 1;

#define REDIRECT_CIN_FROM_FILE
const string INPUT_FILE_NAME = "input.txt";

const int INVALID_ID = -1;
const int INVALID_NODE_DEPTH = -1;
const int TREE_ROOT_NODE_DEPTH = 1;
const int ZERO_CHAR = '0';
const int DIRECTIONS_COUNT = 8;
const int BOARD_DIM = 3;
const int INVALID_ROW_COL_IDX = -1;
const int BYTE_SIZE = 8;

const char ME = 'X';
const char OPPONENT = 'O';
const char EMPTY = 'E';

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

typedef unsigned short int Cells;
const int BOARD_SIZE = sizeof(Cells) * BYTE_SIZE;

class Board {
public:
	Board();
	~Board();

	char getCell(int rowIdx, int colIdx) const;

	void setCell(int rowIdx, int colIdx, char value);

	int emptyCell(int rowIdx, int colIdx) const;

	Cells removeCells(int rowIdx, int colIdx, Cells cells) const;

private:
	Cells emptyCells;
	Cells playersCells;
};

//*************************************************************************************************************
//*************************************************************************************************************

Board::Board() :
	emptyCells(0),
	playersCells(0)
{

}

//*************************************************************************************************************
//*************************************************************************************************************

Board::~Board() {

}

//*************************************************************************************************************
//*************************************************************************************************************

char Board::getCell(int rowIdx, int colIdx) const {
	char cellValue = EMPTY;

	if (!emptyCell(rowIdx, colIdx)) {
		Cells removedCells = removeCells(rowIdx, colIdx, playersCells);

		if (removedCells & 1) {
			cellValue = ME;
		}
		else {
			cellValue = OPPONENT;
		}
	}

	return cellValue;
}

//*************************************************************************************************************
//*************************************************************************************************************

void Board::setCell(int rowIdx, int colIdx, char value) {
	Cells newCellMask = 1;
	newCellMask <<= BOARD_SIZE - 1;

	newCellMask >>= colIdx;
	newCellMask >>= rowIdx * BOARD_DIM;

	if (ME == value) {
		playersCells |= newCellMask;
	}

	emptyCells |= newCellMask;
}

//*************************************************************************************************************
//*************************************************************************************************************

int Board::emptyCell(int rowIdx, int colIdx) const {
	int empty = false;

	Cells removedCells = removeCells(rowIdx, colIdx, emptyCells);

	if (removedCells & 1) {
		empty = true;
	}

	return empty;
}

//*************************************************************************************************************
//*************************************************************************************************************

Cells Board::removeCells(int rowIdx, int colIdx, Cells cells) const {
	Cells removedBottomRows = cells >> (BOARD_DIM - rowIdx);
	Cells removedBackCells = removedBottomRows >> (BOARD_DIM - colIdx);

	return removedBackCells;
}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class State {
public:
	State();
	~State();

private:
	Board board;
};

//*************************************************************************************************************
//*************************************************************************************************************

State::State() {

}

//*************************************************************************************************************
//*************************************************************************************************************

State::~State() {

}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class Game {
public:
	Game();
	~Game();

	void initGame();
	void gameBegin();
	void gameLoop();
	void getGameInput();
	void getTurnInput();
	void turnBegin();
	void makeTurn();
	void turnEnd();
	void play();

	void debug() const;

private:
	int turnsCount;

	Board board;
};

//*************************************************************************************************************
//*************************************************************************************************************

Game::Game() :
	turnsCount(0),
	board()
{

}

//*************************************************************************************************************
//*************************************************************************************************************

Game::~Game() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::initGame() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::gameBegin() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::gameLoop() {
	while (true) {
		turnBegin();
		getTurnInput();
		makeTurn();
		turnEnd();
	}
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::getGameInput() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::getTurnInput() {
	int opponentRow;
	int opponentCol;
	cin >> opponentRow >> opponentCol; cin.ignore();

	if (INVALID_ROW_COL_IDX != opponentRow && INVALID_ROW_COL_IDX != opponentCol) {
		board.setCell(opponentRow, opponentCol, OPPONENT);
	}

	//int validActionCount;
	//cin >> validActionCount; cin.ignore();
	//
	//for (int i = 0; i < validActionCount; i++) {
	//	int row;
	//	int col;
	//	cin >> row >> col; cin.ignore();
	//}
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::turnBegin() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::makeTurn() {
	cout << "0 0" << endl;
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::turnEnd() {
	++turnsCount;
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::play() {
	initGame();
	getGameInput();
	gameBegin();
	gameLoop();
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::debug() const {
}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

#ifdef TESTS
#include "debug.h"
#endif // TESTS

int main(int argc, char** argv) {
#ifdef TESTS
	doctest::Context context;
	int res = context.run();
#else

#ifdef REDIRECT_CIN_FROM_FILE
	ifstream in(INPUT_FILE_NAME);
	streambuf *cinbuf = cin.rdbuf();
	cin.rdbuf(in.rdbuf());
#endif

	Game game;
	game.play();
#endif // TESTS

	return 0;
}